---
title: "┗ おまけ"
free: false
---

この項の内容は理解していなくても大丈夫です。使い方だけわかれば良い方は次へ進んでください。

## ブランチを作成しすぎても良いの？

ブランチの説明で、
> ブランチとは直訳すると枝という意味で、文字通りオリジナルから枝分かれしたコピーの事です。

と最初に書きましたが、あれは嘘です（え？）実際にはコピーはされていません。
Gitはファイルの変更を戻したり出来るように全ての変更履歴（変更前の状態）を保持しています。
厳密には差分情報のようにして元に戻すのに必要な情報を持っています。

ファイルの変更前変更後全てにIDが振られています。
そしてコミットもGit内部ではファイルになっていてIDが振られています。（Sourcetreeで確認できる謎の文字列がそれです）
コミットファイルにはコミットした時にファイルがどの時のものかIDを追跡出来るように記述されています。
そしてブランチはこのコミットIDだけを保持しています。
ブランチを作成するというのは、実はすでにあるコミットにショートカットをつけているだけでファイルのコピー等は一切行われていません。
ですので、いくらブランチを作成してもストレージを圧迫しない優れた仕組みとなっています。

:::message alert
この仕組み（全ての履歴を保持している）のため一度巨大なファイルをコミットしてしまうと、最新履歴でそのファイルを削除しても容量が減らない問題があります。
巨大なファイル（動画などのリソースファイル）は別の仕組みで保存するような工夫が必要な場合があります。
:::

## 実際（内部）の動作

実践の章で行ったことを内部的な視点でもう一度追ってみましょう。

### クローン

cloneを実行するとGitLabからGitオブジェクト（ファイルの変更履歴がIDになった全情報）をダウンロードします。
これはローカルフォルダの「.git¥objects」に全て入っています。
![](/images/books/497459787cb294/practice_e01.png)

次に、リモート追跡ブランチを作成します。
これもローカルフォルダの「.git¥refs¥remotes」に入っています。
ファイルの中身を見るとわかりますが、コミットIDが書かれているだけの小さいテキストファイルがブランチの実態です。

次に、アクティブなブランチ（通常はmainやmaster）を作業用ブランチとして作成します。
作業用ブランチは同名のリモート追跡ブランチを上流ブランチに設定します。

最後に、作業用ブランチをチェックアウトして実ファイルを取り出します。

### ブランチ作成

指定したコミットIDを参照したブランチファイルを作成します。
作業用ブランチは「.git¥refs¥heads」に入っています。

### ステージング

ステージングしたファイルをGitオブジェクトに変換します。

:::message
検証したところ、一度ステージングした後キャンセルしてもGitオブジェクトは削除されないようです。
Gitは定期的にGitオブジェクトを整理しているのでそれまでは一時的にはゴミが残ります。
:::

### コミット

現在のファイル状態を記録したコミットファイルを作成します。
作成したコミットファイル（ID）をアクティブな作業用ブランチファイルに上書きします。

### プッシュ

作成したGitオブジェクトをGitLabにアップロードします。
作業用ブランチを上流ブランチ（リモート追跡ブランチ）とGitLabのリモートブランチに反映します。

### フェッチ

GitLabからGitオブジェクトをダウンロードします。
その後、リモート追跡ブランチもGitLabのリモートブランチと同じ状態にします。

### マージ

アクティブな作業用ブランチが参照しているコミットとマージしたいコミットを比較して、
衝突検知を行い問題がなければ作業用ブランチの参照コミットをマージ先のコミットに上書きします。
この時、マージ先のブランチファイルのコミットIDをマージ元のコミットIDに付け替えるだけの操作がファストフォワードです。
