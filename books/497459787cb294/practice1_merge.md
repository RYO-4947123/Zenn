---
title: "┣ merge(マージ)"
free: false
---

## merge(マージ)

次にmerge(マージ)を行い、フェッチしてきた【リモート】リポジトリの内容を作業用ブランチへ適用します。作業用ブランチに変更が無ければ上書きされ、変更がある場合はコンフリクト(衝突)が発生するので適宜正しい内容になる様に修正が必要となります。

:::message
マージ処理は【リモート】リポジトリと【ローカル】リポジトリの同名のブランチで行う事が一般的ですが、別のブランチへマージする事もできます。
この処理はブランチの結合に関わる処理で色々な応用方法があります。
Gitで一番難しい概念かもしれませんが、とりあえずは同名ブランチを同期する機能ぐらいの認識で大丈夫です。
:::

### 事前準備

GitLabのオンラインファイル編集機能を使って「develop」ブランチの「README.md」を修正しましょう。

ファイル名をクリックします。
![](/images/books/497459787cb294/practice_20.png)

編集方法選択プルダウンから「編集」を選択したあと、プルダウンをクリックします。
（選択しただけだと実行されません）
![](/images/books/497459787cb294/practice_21.png)

適当にファイル内容を編集したあと「Commit changes」をクリックします。
![](/images/books/497459787cb294/practice_22.png)

Sourcetreeに戻って、
フェッチを行って【リモート】リポジトリの内容を取得します。
そうすると、リモートの「develop」ブランチに先ほどのコミット履歴が追加されているはずです。
また、ローカルの「develop」ブランチの横にマークが追加されています。
これは「ローカルに適用されていないリモートの変更があるよ」とわかりやすく表示してくれています。

![](/images/books/497459787cb294/practice_23.png)

このローカルに適用されていない変更を適用するのがマージです。

![](/images/books/497459787cb294/practice_24.png)

:::message alert
現在のブランチがマージしたいブランチ（今回は「develop」）になっているか注意してください。
それと、マージしたい履歴も間違わないように選択してください。
上の画像では、最新の一つ前「Add new file」を選択してしまうと別のブランチの内容をマージしてしまいます。
:::

マージが完了したらファイルの内容を見てみましょう。
GitLabで編集した内容が反映されているはずです。

![](/images/books/497459787cb294/practice_25.png)

## ファストフォワードとマージコミット

マージを実行する時、マージ先のブランチとマージ元のブランチが一直線に繋がっている場合は新たにコミットせずにマージすることができます。
これをファストフォワード(Fast-Forward)と呼びます。

「main」ブランチを元にして「b1」ブランチを作成した後、「main」ブランチに何も変更がない場合は、以下のように一直線になります。
この状態でマージを実行すると、
![](/images/books/497459787cb294/practice_26.png)

新しいコミットが作成されずに「main」ブランチが移動しただけになります。
![](/images/books/497459787cb294/practice_27.png)

「b1」ブランチを作成後に「main」ブランチを変更した（分岐している）場合はマージコミットが作成されます。
![](/images/books/497459787cb294/practice_28.png)

マージ後は新しいコミットが先端に作成されて、それぞれのブランチが合流します。
![](/images/books/497459787cb294/practice_30.png)

マージコミットにどのコミットが取り込まれたかわかりやすくするオプションがあります。
![](/images/books/497459787cb294/practice_29.png)

## リベースマージ

マージコミットを行なった場合、一度分岐してから元のブランチに合流するように履歴が作成されます。
ほとんどの場合これで問題ないのですが、履歴をなるべく一直線にして綺麗にしたいと思うことがあります。
そのような時は**リベース**を使用したマージを行う方法があります。

通常マージコミットが発生するように分岐したブランチを用意します。
![](/images/books/497459787cb294/practice_28.png)

ここで以下のマージオプションを設定します。
![](/images/books/497459787cb294/practice_31.png)

すると、履歴が一直線に修正されています。
![](/images/books/497459787cb294/practice_32.png)

どういった仕組みでしょうか？

### リベースの仕組み

rebase（リベース）はブランチを分岐した時のコミット位置を別のコミットから分岐したように付け替えることができる操作です。
base(分岐した地点)をre(設定し直す)と覚えると良いです。

例では、当初「main」ブランチと「b1」ブランチは一番最初のコミット（test1）から枝分かれしていましたが、
それを「b1」ブランチの最後のコミット（add b1）から分岐したように「main」ブランチの分岐点を付け替えています。

:::message alert
既にGitLabにプッシュしたコミットをrebaseしてはいけません。
なぜなら、リベースして新たな分岐点となった以降の全てのコミットは内部的には新しいコミットとなるからです。
つまりコミットが移動したのではなくコピーしただけなので、他の作業者から見たら古いコミットの方がまだ生きている可能性があるためです。
プッシュする前はローカル上の変更なので他の作業者に影響はありません。
rebaseによってどのコミットがコピーされたかを理解できていない内はrebaseを行わず素直にマージコミットを行いましょう。
:::
